#!/usr/local/bin/ansible-playbook --inventory=inventory
- name: 'Mirror Operators for Disconnected OLM | push-operators-from-arvin-code-to-artifactory.yml' 
  hosts: localhost 
  become: yes
  vars:
    ansible_python_interpreter: /usr/bin/python3
  vars_files:
    - 'vars/vault.yml'
    - 'vars/artifactory.yml'
  vars:
    module: "bundle-operators"
    ansible_name_module: "Mirror Operators for Disconnected OLM | {{ module }}"

  tasks:
    - name: '{{ ansible_name_module }} | block | unpack bundle to controller if required'
      when:
        - unpack_bundle is defined
        - unpack_bundle | bool
      block:
        - name: '{{ ansible_name_module }} | file:directory | Ensure the operator images staging directory exist'
          file:
            path: "{{ item }}"
            state: directory
            mode: 0755
          loop:
            - "{{ dir_bundle_staging }}"

        - name: '{{ ansible_name_module }} | unarchive:xz | original operator bundle on registry '
          unarchive:
            src: "{{ bundle_file_location }}"
            remote_src: yes
            dest: "{{ dir_bundle_staging }}"
            mode: 0755
          register: op_unbundle_out
        
        - name: '{{ ansible_name_module }} | set_fact | registry image files load facts '
          set_fact:
            local_registry_dir: "{{ dir_bundle_staging }}/docker/registry/v2"
        
        - name: '{{ ansible_name_module }} | command:podman:load | load'
          command: podman load -i {{ dir_bundle_staging }}/container-registry-image.tar
          register: registry_container_loaded
        
        - name: '{{ ansible_name_module }} | set_fact | Set loaded registry container image name '
          set_fact:
            temp_container_registry_image: "{{ registry_container_loaded.stdout.split(' ')[2] }}"
          when:
            - registry_container_loaded is defined
            - registry_container_loaded.rc == 0
            - not registry_container_loaded.failed | bool
            - registry_container_loaded is defined
            - registry_container_loaded.stdout != ""
        
        - name: '{{ ansible_name_module }} | shell:podman | Verify there is no existing registry container 1 of 2'
          shell: podman ps | awk '{print $12}' | grep -i {{ registry_container_name }}
          register: running_reg

        - name: '{{ ansible_name_module }} | shell:ss | Verify there is no existing registry container 2 of 2'
          shell: ss -ntlup | grep -i listen | grep 5000
          register: bound_reg

        - name: '{{ ansible_name_module }} | assert | Ensure there is no running registry container'
          assert:
            that:
              - running_reg is defined and running_reg.rc is defined and running_reg.rc == 0 and not {{ registry_container_name }} in running_reg.stdout
              - bound_reg is defined and bound_reg.rc == 0 and not '5000' in bound_reg.stdout
            msg: "A registry container is already running on host. Please shut it down before running this play."

        - name: '{{ ansible_name_module }} | podman:run | Start registry container '
          command: >
            podman run -d --name {{ registry_container_name }} \
            -p 5000:5000 -v {{ dir_bundle_staging }}:/var/lib/registry:z \
            {{ temp_container_registry_image }}
          when:
            - temp_container_registry_image is defined
            - temp_container_registry_image != ""

    - name: '{{ ansible_name_module }} | command | generate authfile for registry'
      no_log: true
      command: >
        podman login -u {{ registry_admin_username }} -p {{ registry_admin_password }} \
           --authfile {{ hostvars[inventory_hostname].ansible_env.HOME }}/.docker/regconfig.json \
           {{ registry_host_fqdn }}
      register: reg_authfile_created

    - name: '{{ ansible_name_module }} | set_fact |  authfile for destination registry'
      set_fact:
        registry_auth_config: "{{ hostvars[inventory_hostname].ansible_env.HOME }}/.docker/regconfig.json"

    - name: '{{ ansible_name_module }} | Process repositories'
      block:
        - name: '{{ ansible_name_module }} | curl | _catalog?n=2000 '
          shell: >
            curl -v http://localhost:5000/v2/_catalog?n=2000 | jq .repositories | grep -i custom
          register: registry_repositories
    
        - name: '{{ ansible_name_module }} | debug | print repositories '
          debug:
            var: registry_repositories

        - name: '{{ ansible_name_module }} | debug | print repositories '
          debug:
            var: item.replace(',', '').replace('"','').replace(' ','') 
          with_items:
            - "{{ registry_repositories.stdout_lines }}"

    - name: '{{ ansible_name_module }} | command:{{ openshift_client_binary }} images | load images to registry '
      command: >
        {{ openshift_client_binary }} image mirror \
           -a {{ registry_auth_config }} \
            localhost:5000/{{ item.replace(',', '').replace('"','').replace(' ','') }}:* \
           {{ registry_host_fqdn }}/{{ local_repository }}/{{ item.replace(',', '').replace('"','').replace(' ','') }} \
           --insecure=true --loglevel=8 --filter-by-os=/*
      with_items:
        - "{{ registry_repositories.stdout_lines }}"
      when:
        - reg_authfile_created is defined
      register: registry_loaded
    
    - name: '{{ ansible_name_module }} | podman:rm | Remove mirror-registry '
      command: podman rm -f {{ registry_container_name | d('mirror-registry') }}
      when:
        - reg_authfile_created is defined
      register: registry_loaded

    - name: '{{ ansible_name_module }} | Process manifests'
      block:
        - name: '{{ ansible_name_module }} | file:directory | Ensure manifest location exist '
          file:
            path: "{{ manifest_dir | d(playbook_dir + '/manifests', true) }}"
            state: directory

        - name: '{{ ansible_name_module }} | find | manifest files folders *-publish '
          find:
            file_type: directory
            patterns:
              - "*-publish"
            paths:
              - "{{ dir_bundle_staging }}" 
          register: manifest_search

        - name: '{{ ansible_name_module }} | set_fact | manifestc search paths'
          set_fact:
            manifest_search_paths: "{{ manifest_search.files | map(attribute='path') | list }}"
      
        - name: '{{ ansible_name_module }} | find | manifest files '
          find:
            file_type: file 
            patterns: '*.yaml,*.txt'
            paths:
              - "{{ item }}" 
          loop: "{{ manifest_search_paths }}"
          register: manifest_files_search

        - name: query file paths
          set_fact:
             manifest_files_search_paths: "{{ manifest_files_search | json_query('results[*].files[*].path') | sum(start=[]) }}"

        - name: '{{ ansible_name_module }} | copy | Ensure manifest location exist '
          copy:
            src: "{{ item }}"
            dest: "{{ manifest_dir | d(playbook_dir + '/manifests', true) }}/{{ (item | dirname).split('/')[-1] }}-{{ item | basename }}"
            force: yes
            mode: 0755
          loop: "{{ manifest_files_search_paths }}"
